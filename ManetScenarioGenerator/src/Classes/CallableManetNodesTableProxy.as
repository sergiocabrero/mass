package Classes
{
	import Entities.*;
	
	import Interfaces.IManetNodesTableReadable;
	import Interfaces.IManetNodesTableWritable;
	
	import mx.utils.ObjectProxy;

	//Proxy de acceso a la tabla de nodos
	public class CallableManetNodesTableProxy extends ObjectProxy implements IManetNodesTableReadable, IManetNodesTableWritable
	{
		private var _item:ManetNodesTable;
		
		public function CallableManetNodesTableProxy(item:Object=null, uid:String=null, proxyDepth:int=-1)
		{
			super(item, uid, proxyDepth);
			this._item = ManetNodesTable(item);
		}
		
		/**
		 * @changes the table of ManetNode objects, removing all the elements
		 **/ 	
		public function clearAll():void
		{
			this._item.clearAll();
		}
		
		/**
		 * @param newManetNode:ManetNode, a ManetNode object to add to the list of ManetNode objects
		 * @param autoId:Boolean, true if the id for the new ManetNode has to be autogenerated, false otherwise
		 * @changes the table of ManetNode objects if the new ManetNode is added
		 * @returns String, the id assigned to the ManetNode added to the list, -1 if the operation fails
		 **/ 
		public function addManetNode(newManetNode:ManetNode, autoId:Boolean):String
		{
			return this._item.addManetNode(newManetNode, autoId);
		}
		
		/**
		 * @param idNode:String, the id of the ManetNode to search
		 * @return ManetNode, a copy of the ManetNode found in the table, null otherwise
		 **/ 
		public function getManetNode(idNode:String):ManetNode
		{
			return this._item.getManetNode(idNode);
		}

		/**
		 * @param idNode:String, the id of the ManetNode to search
		 * @return ManetNode, a reference of the ManetNode found in the table, null otherwise
		 **/ 		
		public function getManetNodeReference(idNode:String):ManetNode
		{
			return this._item.getManetNodeReference(idNode);
		}

		/**
		 * @param idNode:String, receives the id of the ManetNode to update in the list of ManetNode objects
		 * @param newManetNode:ManetNode, a ManetNode object to update an existing ManetNode in the table of ManetNode objects
		 * @changes The table of manet ManetNode objects updating it with the new ManetNode
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function setManetNode(idNode:String, newManetNode:ManetNode):Boolean
		{
			return this._item.setManetNode(idNode, newManetNode);
		}

		/**
		 * @returns Array, a collection of ids of the ManetNode objects in the table
		 **/		
		public function getIdManetNodesArray():Array
		{
			return this._item.getIdManetNodesArray();
		}

		/**
		 * @param idNode:String, receives the id of the ManetNode to remove from the list of ManetNode objects
		 * @changes the table of ManetNode objects if the ManetNode is removed
		 * @returns Boolean, true if the ManetNode is removed from the list of ManetNode objects, false otherwise
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/ 		
		public function removeManetNode(idNode:String):Boolean
		{
			return this._item.removeManetNode(idNode);
		}

		/**
		 * @param idNode:String, the id of the ManetNode to update
		 * @param newIdNode:String, receives the value of the new id for the ManetNode 
		 * @changes the id of the ManetNode is updated
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function setManetNodeId(idNode:String, newIdNode:String):Boolean
		{
			return this._item.setManetNodeId(idNode, newIdNode);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode to update
		 * @param newIdNode:String, receives the value of the new id for the ManetNode 
		 * @changes the id of the ManetNode is updated
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function setManetNodeRange(nodeId:String, newRange:int):Boolean
		{
			return this._item.setManetNodeRange(nodeId, newRange);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns int, the value of the current range
		 **/			
		public function getManetNodeRange(nodeId:String):int
		{
			return this._item.getManetNodeRange(nodeId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode to update
		 * @param newColour:String, receives the value of the new colour for the ManetNode 
		 * @changes the colour of the ManetNode is updated
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function setManetNodeColour(nodeId:String, newColour:String):Boolean
		{
			return this._item.setManetNodeColour(nodeId, newColour);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns String, the value of the current colour
		 **/			
		public function getManetNodeColour(nodeId:String):String
		{
			return this._item.getManetNodeColour(nodeId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode to update
		 * @param newDirection:int, receives the value of the new direction for the ManetNode 
		 * @changes the direction of the ManetNode is updated
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function setManetNodeDirection(nodeId:String, newDirection:int):Boolean
		{
			return this._item.setManetNodeDirection(nodeId, newDirection);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns int, the value of the current direction
		 **/			
		public function getManetNodeDirection(nodeId:String):int
		{
			return this._item.getManetNodeDirection(nodeId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode to update
		 * @param newName:String, receives the value of the new name for the ManetNode 
		 * @changes the name of the ManetNode is updated
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function setManetNodeName(nodeId:String, newName:String):Boolean
		{
			return this._item.setManetNodeName(nodeId, newName);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns String, the value of the current name
		 **/		
		public function getManetNodeName(nodeId:String):String
		{
			return this._item.getManetNodeName(nodeId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode to update
		 * @param newPattern:String, receives the value of the new pattern for the ManetNode 
		 * @changes the pattern of the ManetNode is updated
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function setManetNodePattern(nodeId:String, newPattern:String):Boolean
		{
			return this._item.setManetNodePattern(nodeId, newPattern);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns String, the value of the current pattern
		 **/		
		public function getManetNodePattern(nodeId:String):String
		{
			return this._item.getManetNodePattern(nodeId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode to update
		 * @param timestamp:Date, receives the value of the new time for the state
		 * @param isSwitchedOn:Boolean, receives the value for the switched on state property, false if the ManetNode is switched off, true if it is switched on
		 * @param xCoord:int, the x coordinate corresponding with the state
		 * @param yCoord:int, the y coordinate corresponding with the state
		 * @param zCoord:int, the z coordinate corresponding with the state
		 * @changes the list of states, adding a new node state
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/			
		public function setManetNodeState(nodeId:String, timestamp:Date, isSwitchedOn:Boolean, xCoord:int = -1, yCoord:int = -1, zCoord:int = -1):Boolean
		{
			return this._item.setManetNodeState(nodeId, timestamp, isSwitchedOn, xCoord, yCoord, zCoord);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, receives the time related to the requested state
		 * @returns a NodeState object, a copy of the state in the table corresponding with the requested time or null if it does not exist
		 **/		
		public function getManetNodeStateByTimestamp(nodeId:String, timestamp:Date):NodeState
		{
			return this._item.getManetNodeStateByTimestamp(nodeId, timestamp);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param nodeStateId:int, receives the id of the requested state
		 * @returns a NodeState object, a copy of the state in the table corresponding with the requested id or null if it does not exist
		 **/		
		public function getManetNodeState(nodeId:String, nodeStateId:int):NodeState
		{
			return this._item.getManetNodeState(nodeId, nodeStateId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns a NodeState object, a copy of the first state of the table (chronologically ordered) 
		 **/		
		public function getManetNodeFirstState(nodeId:String):NodeState
		{
			return this._item.getManetNodeFirstState(nodeId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns a NodeState object, a copy of the last state of the table (chronologically ordered) 
		 **/		
		public function getManetNodeLastState(nodeId:String):NodeState
		{
			return this._item.getManetNodeLastState(nodeId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param nodeStateId:int, receives the id of the previous state of the requested
		 * @returns a NodeState object, a copy of the state of the table corresponding with the next state 
		 * to the requested id or null if it does not exist
		 **/		
		public function getManetNodeNextState(nodeId:String, nodeStateId:int):NodeState
		{
			return this._item.getManetNodeNextState(nodeId, nodeStateId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param nodeStateId:int, receives the id of the previous state of the requested
		 * @returns a NodeState object, a copy of the state of the table corresponding with the previous state 
		 * to the requested id or null if it does not exist
		 **/		
		public function getManetNodePreviousState(nodeId:String, nodeStateId:int):NodeState
		{
			return this._item.getManetNodePreviousState(nodeId, nodeStateId);	
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param nodeStateId:int, the id of the state to check
		 * @returns Boolean, true if the provided nodeStateId corresponds to the first state of the list (chronologically ordered)   
		 **/			
		public function isManetNodeFirstState(nodeId:String, nodeStateId:int):Boolean
		{
			return this._item.isManetNodeFirstState(nodeId, nodeStateId);	
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param nodeStateId:int, the id of the state to check
		 * @returns Boolean, true if the provided nodeStateId corresponds to the last state of the list (chronologically ordered)   
		 **/		
		public function isManetNodeLastState(nodeId:String, nodeStateId:int):Boolean
		{
			return this._item.isManetNodeLastState(nodeId, nodeStateId);
		}
		
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestampInit:Date, receives the start time instant of the movement
		 * @param timestampEnd:Date, receives the end time instant of the movement
		 * @param xCoordinateInit:int, receives the x-axis coordinate of the start
		 * @param yCoordinateInit:int, receives the y-axis coordinate of the start
		 * @param xCoordinateEnd:int, receives the x-axis coordinate of the end
		 * @param yCoordinateEnd:int, receives the y-axis coordinate of the end
		 * @param trajectory:int, receives the trajectory of the movement
		 * @param acceleration:int, receives the acceleration of the movement
		 * @param args[0]:Boolean, receives true if the id will be automatically generated, false otherwise
		 * @param args[1]:int, receives the id for the new movement (ignored if args[0] is false)
		 * @changes the list of movements, adding the movement
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/			
		public function setManetNodeMovement(nodeId:String, timestampInit:Date, timestampEnd:Date, xCoordinateInit:int, yCoordinateInit:int, 
					xCoordinateEnd:int, yCoordinateEnd:int, trajectory:int, acceleration:int, ...args):Boolean
		{
			var returnedValue:Boolean;
				
			if (args.length == 0)
			{
				returnedValue = this._item.setManetNodeMovement(nodeId, timestampInit, timestampEnd, xCoordinateInit, yCoordinateInit,
				xCoordinateEnd, yCoordinateEnd, trajectory, acceleration, true);
			}
			else if (args.length == 1)
			{
				if (args[0] == true)
				{
					returnedValue = this._item.setManetNodeMovement(nodeId, timestampInit, timestampEnd, xCoordinateInit, yCoordinateInit,
					xCoordinateEnd, yCoordinateEnd, trajectory, acceleration, args[0]);
				}
				else
				{
					return false;
				}	
			}
			else
			{
				returnedValue = this._item.setManetNodeMovement(nodeId, timestampInit, timestampEnd, xCoordinateInit, yCoordinateInit,
				xCoordinateEnd, yCoordinateEnd, trajectory, acceleration, args[0], args[1]);
			}
			return returnedValue;
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param movementId:int, the id of the movement to check
		 * @returns Boolean, true if the provided nodeStateId corresponds to the first movement of the list (chronologically ordered)   
		 **/		
		public function isManetNodeFirstMovement(nodeId:String, movementId:int):Boolean
		{
			return this._item.isManetNodeFirstMovement(nodeId, movementId);
		}

		//SIN USO ACTUALMENTE
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param movementId:int, the id of the movement to check
		 * @returns Boolean, true if the provided nodeStateId corresponds to the first movement of a stretch from the list (chronologically ordered)   
		 **/		
		public function isManetNodeFirstStretchMovement(nodeId:String, movementId:int):Boolean
		{
			return this._item.isManetNodeFirstStretchMovement(nodeId, movementId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param movementId:int, the id of the movement to check
		 * @returns Boolean, true if the provided nodeStateId corresponds to the last movement of the list (chronologically ordered)   
		 **/			
		public function isManetNodeLastMovement(nodeId:String, movementId:int):Boolean
		{
			return this._item.isManetNodeLastMovement(nodeId, movementId);
		}

		//SIN USO ACTUALMENTE
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param movementId:int, the id of the movement to check
		 * @returns Boolean, true if the provided nodeStateId corresponds to the last movement of a stretch from the list (chronologically ordered)   
		 **/		
		public function isManetNodeLastStretchMovement(nodeId:String, movementId:int):Boolean
		{
			return this._item.isManetNodeLastStretchMovement(nodeId, movementId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns Movement, the first movement of the list (chronologically ordered), null if the list is empty
		 **/		
		public function getManetNodeFirstMovement(nodeId:String):Movement
		{
			return this._item.getManetNodeFirstMovement(nodeId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns Movement, the last movement of the list (chronologically ordered), null if the list is empty
		 **/		
		public function getManetNodeLastMovement(nodeId:String):Movement
		{
			return this._item.getManetNodeLastMovement(nodeId);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestampInit:Date, receives the start time of the previous movement of the requested
		 * @param timestampEnd:Date, receives the start time of the previous movement of the requested
		 * @returns Movement object, a copy of the movement of the table corresponding with the next movement 
		 * of the movement starting and ending at the requested timestamps or null otherwise
		 **/	
		public function getManetNodeNextMovementByInitEnd(nodeId:String, timestampInit:Date, timestampEnd:Date):Movement
		{
			return this._item.getManetNodeNextMovementByInitEnd(nodeId, timestampInit, timestampEnd);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, receives the time of a checkpoint
		 * @returns TimestampPositionCheckpoint object, a copy of the checkpoint corresponding with the first match,
		 * being a movement start or end point 
		 **/		
		public function getManetNodeTimestampPositionCheckpoint(nodeId:String, timestamp:Date):TimestampPositionCheckpoint
		{
			return this._item.getManetNodeTimestampPositionCheckpoint(nodeId, timestamp);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestampInit:Date, receives the start time of the next movement of the requested
		 * @param timestampEnd:Date, receives the start time of the next movement of the requested
		 * @returns Movement object, a copy of the movement of the table corresponding with the previous movement 
		 * of the movement starting and ending at the requested timestamps or null otherwise
		 **/			
		public function getManetNodePreviousMovementByInitEnd(nodeId:String, timestampInit:Date, timestampEnd:Date):Movement
		{
			return this._item.getManetNodePreviousMovementByInitEnd(nodeId, timestampInit, timestampEnd);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param movementId:int, receives the id of the previous movement of the requested
		 * @returns Movement object, a copy of the movement of the table corresponding with the next movement 
		 * to the requested id or null if it does not exist
		 **/
		public function getManetNodeNextMovement(nodeId:String, movementId:int):Movement
		{
			return this._item.getManetNodeNextMovement(nodeId, movementId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param movementId:int, receives the id of the next movement of the requested
		 * @returns Movement object, a copy of the movement of the table corresponding with the next movement 
		 * to the requested id or null if it does not exist
		 **/		
		public function getManeNodePreviousMovement(nodeId:String, movementId:int):Movement
		{
			return this._item.getManetNodePreviousMovement(nodeId, movementId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, the time to search in the list of PositionCheckpoints
		 * @returns TimestampPositionCheckpoint, in case the searched time is found it returns a copy of the position.
		 * If is not found but the time is between two existing time checkpoints it returns a interpolated TimestampPositionCheckpoint,
		 * null otherwise
		 **/					
		public function getManetNodeEstimatedTimestampPositionCheckpoint(nodeId:String, timestamp:Date):TimestampPositionCheckpoint
		{
			return this._item.getManetNodeEstimatedTimestampPositionCheckpoint(nodeId, timestamp);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param movementId:int, the id of the requested movement
		 * @returns Movement, in case the searched id is found it returns a copy of the movement, null otherwise.
		 **/		
		public function getManetNodeMovement(nodeId:String, movementId:int):Movement
		{
			return this._item.getManetNodeMovement(nodeId, movementId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, the time of the requested movement
		 * @returns Movement, in case the searched id is found it returns a copy of the movement, null otherwise.
		 **/		
		public function getManetNodeMovementByTimestamp(nodeId:String, timestamp:Date):Movement
		{
			return this._item.getManetNodeMovementByTimestamp(nodeId, timestamp);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestampInit:Date, the start time of the requested movement
		 * @param timestampEnd:Date, the arrival time of the requested movement 
		 * @returns Movement, in case the searched movement according to timestamps is found it returns 
		 * a copy of the movement, null otherwise.
		 **/		
		public function getManetNodeMovementByInitEnd(nodeId:String, timestampInit:Date, timestampEnd:Date):Movement
		{
			return this._item.getManetNodeMovementByInitEnd(nodeId, timestampInit, timestampEnd);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns TimestampPositionCheckpoint, the first timestamp found in the list of checkpoints if the list
		 * is not empty, null otherwise
		 **/ 		
		public function getManetNodeFirstTimestampPositionCheckpoint(nodeId:String):TimestampPositionCheckpoint
		{
			return this._item.getManetNodeFirstTimestampPositionCheckpoint(nodeId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns TimestampPositionCheckpoint, the last timestamp found in the list of checkpoints if the list 
		 * is not empty, null otherwise
		 **/ 		
		public function getManetNodeLastTimestampPositionCheckpoint(nodeId:String):TimestampPositionCheckpoint
		{
			return this._item.getManetNodeLastTimestampPositionCheckpoint(nodeId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, receives the time of the previous checkpoint of the requested
		 * @returns TimestampPositionCheckpoint, the next checkpoint according to the provided timestamp parameter,
		 * null otherwise
		 **/ 		
		public function getManetNodeNextTimestampPositionCheckpoint(nodeId:String, timestamp:Date):TimestampPositionCheckpoint
		{
			return this._item.getManetNodeNextTimestampPositionCheckpoint(nodeId, timestamp);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, receives a timestamp
		 * @returns TimestampPositionCheckpoint, the immediate previous checkpoint according to the provided timestamp
		 * parameter if that checkpoint exists, null otherwise
		 **/ 		
		public function getManetNodePreviousTimestampPositionCheckpoint(nodeId:String, timestamp:Date):TimestampPositionCheckpoint
		{
			return this._item.getManetNodePreviousTimestampPositionCheckpoint(nodeId, timestamp);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestampArrival:Date, receives the time of the previous checkpoint of the requested
		 * @param timestampStart:Date, receives the time of the previous checkpoint of the requested
		 * @param newTimestampArrival:Date, receives the time of the previous checkpoint of the requested
		 * @param newTimestampStart:Date, receives the time of the previous checkpoint of the requested
		 * @param newXCoordinate:int, receives the x-axis coordinate for the checkpoint to update
		 * @param newYCoordinate:int, receives the y-axis coordinate for the checkpoint to update
		 * @param recalculatingTrajectories:Boolean true if function called from "google" translation between coordinates //FR
		 * @changes the list of movements, updating the movement corresponding with the provided timestamps
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/ 
		 //FR		
		public function updateManetNodeTimestampPositionCheckpoint(nodeId:String, timestampArrival:Date, timestampStart:Date, newTimestampArrival:Date, newTimestampStart:Date, newXCoordinate:int, newYCoordinate:int, recalculatingTrajectories:Boolean):Boolean
		{
			return this._item.updateManetNodeTimestampPositionCheckpoint(nodeId, timestampArrival, timestampStart, newTimestampArrival, newTimestampStart,newXCoordinate, newYCoordinate, recalculatingTrajectories);
		}
		/*public function updateManetNodeTimestampPositionCheckpoint(nodeId:String, timestampArrival:Date, timestampStart:Date, newTimestampArrival:Date, newTimestampStart:Date, newXCoordinate:int, newYCoordinate:int):Boolean
		{
			return this._item.updateManetNodeTimestampPositionCheckpoint(nodeId, timestampArrival, timestampStart, newTimestampArrival, newTimestampStart,newXCoordinate, newYCoordinate);
		}*/
		//FR
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestampArrival:Date, receives the time instant of the checkpoint
		 * @param timestampStart:Date, receives the time instant of the checkpoint
		 * @param xCoordinate:int, receives the x-axis coordinate of the checkpoint
		 * @param yCoordinate:int, receives the y-axis coordinate of the checkpoint
		 * @changes the list of movements, adding or updating the checkpoint
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function addManetNodeDoubleTimestampPositionCheckpoint(nodeId:String, timestampArrival:Date, timestampStart:Date, xCoordinate:int, yCoordinate:int):Boolean
		{
			return this._item.addManetNodeDoubleTimestampPositionCheckpoint(nodeId, timestampArrival, timestampStart, xCoordinate, yCoordinate);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, receives the time instant of the checkpoint
		 * @param xCoordinate:int, receives the x-axis coordinate of the checkpoint
		 * @param yCoordinate:int, receives the y-axis coordinate of the checkpoint
		 * @changes the list of movements, adding a movement starting at the point and time determinated by parameters
		 * and ending at the starting point of the first movement; or adding a movement ending at the point and time 
		 * determinated by parameters and starting at the ending point of the last movement
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/			
		public function addManetNodeExtremeTimestampPositionCheckpoint(nodeId:String, timestamp:Date, xCoordinate:int, yCoordinate:int):Boolean
		{
			return this._item.addManetNodeExtremeTimestampPositionCheckpoint(nodeId, timestamp, xCoordinate, yCoordinate);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestampArrival:Date, receives the time of the arrival to the checkpoint
		 * @param timestampStart:Date, receives the time of start from the checkpoint
		 * @param xCoordinate:int, receives the x-axis coordinate of the checkpoint
		 * @param yCoordinate:int, receives the y-axis coordinate of the checkpoint
		 * @changes the list of movements, adding a movement based on the entered checkpoint, 
		 * and in cases modifying other existing movement
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/		
		public function addManetNodeDoubleIntermediateTimestampPositionCheckpoint(nodeId:String, timestampArrival:Date, timestampStart:Date, xCoordinate:int, yCoordinate:int):Boolean
		{
			return this._item.addManetNodeDoubleIntermediateTimestampPositionCheckpoint(nodeId, timestampArrival, timestampStart, xCoordinate, yCoordinate);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, receives a timestamp corresponding with the checkpoint to remove
		 * @changes the list of movements, removing a movement if exists, and updating movements if necessary
		 * @returns Boolean, true if the operation was succesful, false otherwise
		 **/ 		
		public function removeManetNodeTimestampPositionCheckpoint(nodeId:String, timestamp:Date):Boolean
		{
			return this._item.removeManetNodeTimestampPositionCheckpoint(nodeId, timestamp);
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestamp:Date, the timestamp related to the checkpoint to be removed from the list of checkpoints
		 * @changes the list of movements, removing a movement if exists, and updating movements if necessary
		 * @returns Boolean, true if the movement was deleted from the list, false otherwise
		 **/		
		public function removeManetNodeMovementByTimestamp(nodeId:String, timestamp:Date):Boolean
		{
			return this._item.removeManetNodeMovementByTimestamp(nodeId, timestamp);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param timestampInit:Date, the start timestamp of the movement to be removed
		 * @param timestampEnd:Date, the end timestamp of the movement to be removed
		 * @changes the list of movements, removing a movement if exists, and updating movements if necessary
		 * @returns Boolean, true if the movement was deleted from the list, false otherwise
		 **/		
		public function removeManetNodeMovement(nodeId:String, timestampInit:Date, timestampEnd:Date):Boolean
		{
			return this._item.removeManetNodeMovement(nodeId, timestampInit, timestampEnd);
		}				
				
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns int, the size of the movements list (the amount of movements)
		 **/																																										
		public function getManetNodeMovementsSize(nodeId:String):int
		{
			return this._item.getManetNodeMovementsSize(nodeId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns int, the size of the movements list (the amount of states)
		 **/		
		public function getManetNodeStatesSize(nodeId:String):int
		{
			return this._item.getManetNodeStatesSize(nodeId);
		}
		
		/**
		 * @returns int, the size of the ManetNode objects list (the amount of ManetNode objects)
		 **/			
		public function getManetNodeTableSize():int
		{
			return this._item.getManetNodeTableSize();
		}

		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns Array, a collection of ids of the states in the list
		 **/
		public function getManetNodeIdStatesArray(nodeId:String):Array
		{
			return this._item.getManetNodeIdStatesArray(nodeId);
		}
		
		/**
		 * @param nodeId:String, the id of the ManetNode
		 * @returns Array, a collection of ids of the movements in the list
		 **/		
		public function getManetNodeIdMovementsArray(nodeId:String):Array
		{
			return this._item.getManetNodeIdMovementsArray(nodeId);
		}
		
/**********************************************************************************************************************************/
//FR
/**
		 * @param nodeId:String, the id of the ManetNode
		 * @param switchOn:Boolean, receives the value of the State, On/Off
		 * @param timestamp:Date, receives the time of the nodeState
		 * @param newTimestampArrival:Date, receives the time of the previous checkpoint of the requested
		 * @param newTimestampStart:Date, receives the time of the previous checkpoint of the requested
		 * @param xPosition:int, receives the x-axis coordinate for the nodeState to update
		 * @param yPosition:int, receives the y-axis coordinate for the nodeState to update
		 * @param zPosition:int, receives the z-axis coordinate for the nodeState to update
		 * @changes the list of states, updating the nodeState corresponding with the provided timestamp
		 * @returns Boolean, true if the operation was successful, false otherwise
		 **/ 
		
		public function updateManetNodeState(nodeId:String,switchOn:Boolean,timestamp:Date,xPosition:int=-1,yPosition:int=-1,zPosition:int=-1):Boolean
		{
			return this._item.updateManetNodeState(nodeId,switchOn,timestamp,xPosition,yPosition,zPosition);
		}
		
	}
}

